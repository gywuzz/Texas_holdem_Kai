<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>For_Kai - å¾·å·æ‰‘å…‹ç”Ÿæ—¥ç¤¼ç‰©</title>
  <style>
    body {
      background: #0b1020;
      color: #f5f5f5;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
      margin: 0;
      padding: 0;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 16px;
    }

    h1 {
      text-align: center;
      margin-bottom: 4px;
    }

    .subtitle {
      text-align: center;
      font-size: 16px;
      color: #c0c0c0;
      margin-bottom: 18px;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .top-bar span {
      font-size: 14px;
    }

    button {
      padding: 8px 14px;
      font-size: 14px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #4dd0e1;
      color: #0b1020;
      font-weight: bold;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    button:hover:enabled {
      opacity: 0.9;
    }

    .board {
      text-align: center;
      margin-bottom: 16px;
    }

    .board-title {
      font-size: 16px;
      margin-bottom: 6px;
    }

    .cards {
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .card {
      min-width: 40px;
      padding: 6px 8px;
      border-radius: 6px;
      background: #1b2238;
      text-align: center;
      font-size: 18px;
    }

    .players-row-top,
    .players-row-bottom {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .player {
      background: #141a30;
      border-radius: 8px;
      padding: 8px 10px;
      min-width: 180px;
    }

    .player.me {
      border: 1px solid #4dd0e1;
      box-shadow: 0 0 8px rgba(77, 208, 225, 0.5);
    }

    .player-header {
      font-weight: bold;
      margin-bottom: 4px;
      color: #ffffff;
    }

    .player-cards {
      display: flex;
      gap: 10px;
      margin-bottom: 4px;
    }

    .info-line {
      font-size: 12px;
      color: #d0d0d0;
    }

    .info-line.chips {
      color: #ffd24c;
    }

    .info-line.bet {
      color: #ffffff;
    }

    .info-line.status {
      color: #c0c0c0;
    }

    .info-line.handType {
      color: #9fa8da;
    }

    .winner {
      color: #ffd24c;
      font-weight: bold;
    }

    .status-bar {
      margin-top: 8px;
      text-align: center;
      font-size: 14px;
      color: #ffffff;
    }

    .footer-note {
      text-align: center;
      font-size: 12px;
      color: #9e9e9e;
      margin-top: 4px;
    }

    .action-bar {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 6px;
    }
        /* ğŸ å½©è›‹æŒ‰é’® */
        .surprise-btn{
      position: fixed;
      right: 14px;
      bottom: 14px;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 999px;
      background: #ffd24c;
      color: #0b1020;
      box-shadow: 0 0 10px rgba(255,210,76,0.7);
      z-index: 9999;
    }

    .surprise-btn:hover{
      transform: translateY(-1px);
    }

    /* å½©è›‹å¼¹å±‚é®ç½© */
    .surprise-modal{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9998;
    }

    .surprise-modal.hidden{
      display: none;
    }

    /* å½©è›‹å¡ç‰‡ */
    .surprise-card{
      background: #141a30;
      border: 1px solid #4dd0e1;
      padding: 18px 20px;
      border-radius: 12px;
      width: 320px;
      text-align: center;
      box-shadow: 0 0 18px rgba(77,208,225,0.6);
      animation: pop 0.25s ease-out;
    }

    .surprise-title{
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 8px;
      color: #ffd24c;
    }

    .surprise-text{
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 12px;
      color: #ffffff;
    }

    .close-btn{
      background: #4dd0e1;
      color: #0b1020;
      font-weight: bold;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      border: none;
    }
    .snake-wrap{
      display: flex;
      justify-content: center;
      text-align: center;
      margin-top: 6px;
      margin-bottom: 8px;
      opacity: 0.95;
      pointer-events: none;
    }
    .snake {
      width: 180px;
    }

    @keyframes pop{
      from{ transform: scale(0.92); opacity: 0; }
      to{ transform: scale(1); opacity: 1; }
    }

  </style>
</head>
<body>
<div class="container">
  <h1>Happy Birthday to Kai ğŸ‚</h1>
  <div class="subtitle">
    ä¸€å±€å¾·å·ï¼Œå¥½è¿è¿è¿ï¼Œå¤©å¤©éƒ½æ‰‹æ¡å¥½ç‰Œï¼
  </div>

  <div class="top-bar">
    <span id="streetLabel">é˜¶æ®µï¼š-</span>
    <span id="potLabel">åº•æ± ï¼š0</span>
    <button id="newRoundBtn">å¼€å§‹æ–°å±€</button>
  </div>

  <div class="board">
    <div class="board-title">å…¬å…±ç‰Œ</div>
    <div class="cards" id="communityCards"></div>
  </div>

  <div class="players-row-top">
    <div class="player" data-player-index="1">
      <div class="player-header" data-role="title">ç©å®¶ 2</div>
      <div class="player-cards" data-role="cards"></div>
      <div class="info-line chips" data-role="chips">ç­¹ç : 1000</div>
      <div class="info-line bet" data-role="bet">æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š0</div>
      <div class="info-line status" data-role="status">çŠ¶æ€: ç­‰å¾…</div>
      <div class="info-line handType" data-role="handType">ç‰Œå‹ï¼š-</div>
    </div>
    <div class="player" data-player-index="2">
      <div class="player-header" data-role="title">ç©å®¶ 3</div>
      <div class="player-cards" data-role="cards"></div>
      <div class="info-line chips" data-role="chips">ç­¹ç : 1000</div>
      <div class="info-line bet" data-role="bet">æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š0</div>
      <div class="info-line status" data-role="status">çŠ¶æ€: ç­‰å¾…</div>
      <div class="info-line handType" data-role="handType">ç‰Œå‹ï¼š-</div>
    </div>
    <div class="player" data-player-index="3">
      <div class="player-header" data-role="title">ç©å®¶ 4</div>
      <div class="player-cards" data-role="cards"></div>
      <div class="info-line chips" data-role="chips">ç­¹ç : 1000</div>
      <div class="info-line bet" data-role="bet">æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š0</div>
      <div class="info-line status" data-role="status">çŠ¶æ€ï¼šç­‰å¾…</div>
      <div class="info-line handType" data-role="handType">ç‰Œå‹ï¼š-</div>
    </div>
  </div>

  <div class="players-row-bottom">
    <div class="player me" data-player-index="0">
      <div class="player-header" data-role="title">ç©å®¶ 1ï¼ˆKaiï¼‰</div>
      <div class="player-cards" data-role="cards"></div>
      <div class="info-line chips" data-role="chips">ç­¹ç : 1000</div>
      <div class="info-line bet" data-role="bet">æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š0</div>
      <div class="info-line status" data-role="status">çŠ¶æ€ï¼šç­‰å¾…</div>
      <div class="info-line handType" data-role="handType">ç‰Œå‹ï¼š-</div>
    </div>
  </div>
  <!-- ğŸ å½©è›‹å°æŒ‰é’® -->
  <button id="surpriseBtn" class="surprise-btn" title="ç‚¹æˆ‘æœ‰æƒŠå–œ">ç‚¹æˆ‘çœ‹ç¥è¾</button>

  <!-- å½©è›‹å¼¹å±‚ï¼ˆé»˜è®¤éšè—ï¼‰ -->
  <div id="surpriseModal" class="surprise-modal hidden">
    <div class="surprise-card">
      <div class="surprise-title">Kai ç”Ÿæ—¥å¿«ä¹ï¼ğŸ¥³</div>
      <div class="surprise-text">
        æ„¿36å²åæ¯ä¸€æ‰‹éƒ½æ˜¯å¥½ç‰Œâœ¨<br/>
        <br/>
        è¿ç­¹å¸·å¹„ï¼Œé•¿æœŸå¤åˆ©ï¼Œäººç”Ÿèµ¢å®¶ï¼ğŸ’°<br/>
      </div>
      <button id="closeSurpriseBtn" class="close-btn">å…³é—­</button>
    </div>
  </div>
  <!-- å¯çˆ±å°è›‡ -->
   <div class="snake-wrap">
    <img src="my_snake.png" class = "snake">
   </div>

  <div class="action-bar">
    <button id="btnCall">è·Ÿæ³¨ / çœ‹ç‰Œ</button>
    <button id="btnRaise">åŠ æ³¨ (+20)</button>
    <button id="btnFold">å¼ƒç‰Œ</button>
  </div>

  <div class="status-bar" id="statusBar">
    ç‚¹å‡»ã€Œå¼€å§‹æ–°å±€ã€å¼€å§‹æ¸¸æˆï¼ŒKai æ§åˆ¶ç©å®¶ 1ã€‚
  </div>
  <div class="footer-note">
    * è§„åˆ™å°½é‡å‚è€ƒ Python æ¡Œé¢ç‰ˆï¼š4äººã€ç­¹ç ã€ç›²æ³¨ã€Preflop / Flop / Turn / Riverã€ç®€å• AIã€‚
  </div>
</div>

<script>
  // ---------- ç‰Œä¸ç‰Œå‹åˆ¤æ–­ï¼ˆå¯¹åº” Python ç‰ˆ create_deck / evaluate_*ï¼‰ ----------

  const SUITS = ["â™ ", "â™¥", "â™¦", "â™£"];
  const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
  const RANK_VALUE = {};
  RANKS.forEach((r, i) => { RANK_VALUE[r] = i + 2; });

  const HAND_CATEGORY_NAME = {
    8: "åŒèŠ±é¡º",
    7: "å››æ¡",
    6: "è‘«èŠ¦",
    5: "åŒèŠ±",
    4: "é¡ºå­",
    3: "ä¸‰æ¡",
    2: "ä¸¤å¯¹",
    1: "ä¸€å¯¹",
    0: "é«˜ç‰Œ",
  };

  function createDeck() {
    const deck = [];
    for (const s of SUITS) {
      for (const r of RANKS) {
        deck.push({rank: r, suit: s});
      }
    }
    return deck;
  }

  function shuffle(deck) {
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
  }

  function cardStr(card) {
    return card.rank + card.suit;
  }

  function evaluate5cards(cards5) {
    const ranks = cards5.map(c => RANK_VALUE[c.rank]).sort((a, b) => b - a);
    const suits = cards5.map(c => c.suit);
    const counts = {};
    ranks.forEach(v => { counts[v] = (counts[v] || 0) + 1; });

    const countRank = Object.entries(counts)
      .map(([v, c]) => [parseInt(v), c])
      .sort((a, b) => {
        if (b[1] !== a[1]) return b[1] - a[1];
        return b[0] - a[0];
      });

    const isFlush = new Set(suits).size === 1;
    const uniqueRanks = [...new Set(ranks)].sort((a, b) => b - a);
    let isStraight = false;
    let highCard = Math.max(...uniqueRanks);

    if (uniqueRanks.length === 5 && uniqueRanks[0] - uniqueRanks[4] === 4) {
      isStraight = true;
      highCard = uniqueRanks[0];
    }
    const setRanks = new Set(uniqueRanks);
    if (setRanks.size === 5 &&
      setRanks.has(14) &&
      setRanks.has(5) &&
      setRanks.has(4) &&
      setRanks.has(3) &&
      setRanks.has(2)) {
      isStraight = true;
      highCard = 5;
    }

    if (isStraight && isFlush) {
      return [8, [highCard]];
    }
    if (countRank[0][1] === 4) {
      const four = countRank[0][0];
      const kicker = ranks.find(v => v !== four);
      return [7, [four, kicker]];
    }
    if (countRank[0][1] === 3 && countRank[1][1] === 2) {
      const three = countRank[0][0];
      const pair = countRank[1][0];
      return [6, [three, pair]];
    }
    if (isFlush) {
      return [5, [...ranks].sort((a, b) => b - a)];
    }
    if (isStraight) {
      return [4, [highCard]];
    }
    if (countRank[0][1] === 3) {
      const three = countRank[0][0];
      const kickers = [...new Set(ranks.filter(v => v !== three))].sort((a, b) => b - a);
      return [3, [three, ...kickers]];
    }
    if (countRank[0][1] === 2 && countRank[1][1] === 2) {
      const highPair = Math.max(countRank[0][0], countRank[1][0]);
      const lowPair = Math.min(countRank[0][0], countRank[1][0]);
      const kicker = ranks.find(v => v !== highPair && v !== lowPair);
      return [2, [highPair, lowPair, kicker]];
    }
    if (countRank[0][1] === 2) {
      const pair = countRank[0][0];
      const kickers = [...new Set(ranks.filter(v => v !== pair))].sort((a, b) => b - a);
      return [1, [pair, ...kickers]];
    }
    return [0, [...ranks].sort((a, b) => b - a)];
  }

  function compareHands(h1, h2) {
    if (h1[0] !== h2[0]) return h1[0] - h2[0];
    const a = h1[1];
    const b = h2[1];
    const len = Math.max(a.length, b.length);
    for (let i = 0; i < len; i++) {
      const va = a[i] || 0;
      const vb = b[i] || 0;
      if (va !== vb) return va - vb;
    }
    return 0;
  }

  function evaluate7cards(cards7) {
    let best = null;
    const n = cards7.length;
    for (let a = 0; a < n; a++) {
      for (let b = a + 1; b < n; b++) {
        for (let c = b + 1; c < n; c++) {
          for (let d = c + 1; d < n; d++) {
            for (let e = d + 1; e < n; e++) {
              const comb = [cards7[a], cards7[b], cards7[c], cards7[d], cards7[e]];
              const val = evaluate5cards(comb);
              if (!best || compareHands(val, best) > 0) {
                best = val;
              }
            }
          }
        }
      }
    }
    return best;
  }

  // ---------- æ¸¸æˆçŠ¶æ€ï¼ˆå¯¹åº” Python æˆå‘˜å˜é‡ï¼‰ ----------

  const NUM_PLAYERS = 4;
  const SMALL_BLIND = 10;
  const BIG_BLIND = 20;

  let deck = [];
  let playersCards = []; // [[card, card], ...]
  let communityCards = [];
  let chips = new Array(NUM_PLAYERS).fill(1000);
  let inHand = new Array(NUM_PLAYERS).fill(true);
  let bets = new Array(NUM_PLAYERS).fill(0);
  let totalBets = new Array(NUM_PLAYERS).fill(0);
  let pot = 0;
  let currentBet = 0;
  let dealerIndex = -1;
  let street = "preflop"; // "preflop", "flop", "turn", "river"
  let handActive = false;
  let revealAll = false;

  const streetNames = {
    "preflop": "Preflop",
    "flop": "Flop",
    "turn": "Turn",
    "river": "River",
    "end": "ç»“æŸ",
  };

  // ---------- DOM è·å–ç®€åŒ– ----------

  function qs(selector) { return document.querySelector(selector); }
  function qsa(selector) { return Array.from(document.querySelectorAll(selector)); }

  function playerElements(i) {
    const root = qs(`.player[data-player-index="${i}"]`);
    return {
      root,
      title: root.querySelector('[data-role="title"]'),
      cards: root.querySelector('[data-role="cards"]'),
      chips: root.querySelector('[data-role="chips"]'),
      bet: root.querySelector('[data-role="bet"]'),
      status: root.querySelector('[data-role="status"]'),
      handType: root.querySelector('[data-role="handType"]'),
    };
  }

  // ---------- UI æ›´æ–° ----------

  function renderCommunity() {
    const board = qs('#communityCards');
    board.innerHTML = "";
    for (let i = 0; i < 5; i++) {
      const div = document.createElement('div');
      div.className = 'card';
      if (i < communityCards.length) {
        div.textContent = cardStr(communityCards[i]);
      } else {
        div.textContent = "ğŸ‚ ";
      }
      board.appendChild(div);
    }
  }

  function renderPlayers() {
    for (let i = 0; i < NUM_PLAYERS; i++) {
      const elems = playerElements(i);
      // æ ‡è®°åº„å®¶
      let titleText;
      if (i === 0) titleText = "ç©å®¶ 1ï¼ˆKaiï¼‰";
      else titleText = `ç©å®¶ ${i + 1}`;
      if (i === dealerIndex) titleText += " (åº„)";
      elems.title.textContent = titleText;

      // æ‰‹ç‰Œæ˜¾ç¤ºï¼šKai è‡ªå·±å§‹ç»ˆå¯è§ï¼›å…¶ä»–ç©å®¶åªæœ‰æ‘Šç‰Œæ—¶æ˜¾ç¤º
      elems.cards.innerHTML = "";
      const showCards = (i === 0) || revealAll;
      if (inHand[i] && playersCards[i].length === 2) {
        for (let j = 0; j < 2; j++) {
          const div = document.createElement('div');
          div.className = 'card';
          if (showCards) {
            div.textContent = cardStr(playersCards[i][j]);
          } else {
            div.textContent = "ğŸ‚ ";
          }
          elems.cards.appendChild(div);
        }
      } else {
        for (let j = 0; j < 2; j++) {
          const div = document.createElement('div');
          div.className = 'card';
          div.textContent = "ğŸ‚ ";
          elems.cards.appendChild(div);
        }
      }

      elems.chips.textContent = `ç­¹ç ï¼š${chips[i]}`;
      elems.bet.textContent = `æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š${totalBets[i]}`;
      // status / handType ä¿æŒåŸæœ‰æ–‡å­—ï¼Œä¸åœ¨è¿™é‡Œè¦†ç›–
    }
    qs('#potLabel').textContent = `åº•æ± ï¼š${pot}`;
    qs('#streetLabel').textContent = `é˜¶æ®µï¼š${streetNames[street] || "-"}`;
  }

  function setStatusBar(text) {
    qs('#statusBar').textContent = text;
  }

  function enableActionButtons(enable) {
    ['#btnCall', '#btnRaise', '#btnFold'].forEach(id => {
      qs(id).disabled = !enable;
    });
  }

  // ---------- æ ¸å¿ƒæ¸¸æˆé€»è¾‘ï¼ˆå¯¹åº” Python ä¸­çš„æ–¹æ³•ï¼‰ ----------

  function resetForNewHand() {
    deck = createDeck();
    shuffle(deck);
    playersCards = Array.from({length: NUM_PLAYERS}, () => []);
    communityCards = [];
    bets = new Array(NUM_PLAYERS).fill(0);
    totalBets = new Array(NUM_PLAYERS).fill(0);
    pot = 0;
    currentBet = 0;
    street = "preflop";
    handActive = true;
    revealAll = false;

    inHand = chips.map(c => c > 0); // ç­¹ç >0 æ‰èƒ½å‚ä¸æœ¬å±€
  }

  function dealHoleCards() {
    for (let r = 0; r < 2; r++) {
      for (let i = 0; i < NUM_PLAYERS; i++) {
        if (inHand[i]) {
          playersCards[i].push(deck.pop());
        }
      }
    }
  }

  function postBlinds() {
    const sb = (dealerIndex + 1) % NUM_PLAYERS;
    const bb = (dealerIndex + 2) % NUM_PLAYERS;

    for (let i = 0; i < NUM_PLAYERS; i++) {
      const elems = playerElements(i);
      if (inHand[i]) {
        elems.status.textContent = "çŠ¶æ€ï¼šåœ¨å±€ä¸­";
      } else {
        elems.status.textContent = "çŠ¶æ€ï¼šç­¹ç è€—å°½";
      }
      elems.handType.textContent = "ç‰Œå‹ï¼š-";
      elems.handType.classList.remove('winner');
    }

    // å°ç›²
    takeBet(sb, SMALL_BLIND);
    playerElements(sb).status.textContent = "çŠ¶æ€ï¼šå°ç›²æ³¨";

    // å¤§ç›²
    takeBet(bb, BIG_BLIND);
    playerElements(bb).status.textContent = "çŠ¶æ€ï¼šå¤§ç›²æ³¨";

    currentBet = BIG_BLIND;
  }

  function takeBet(player, amount) {
    if (!inHand[player]) return;
    if (amount <= 0) return;
    const actual = Math.min(amount, chips[player]);
    if (actual <= 0) return;
    chips[player] -= actual;
    bets[player] += actual;        // æœ¬è½®ä¸‹æ³¨ï¼ˆå½“å‰è¡—ï¼‰
    totalBets[player] += actual;   // æœ¬å±€ç´¯è®¡ä¸‹æ³¨
    pot += actual;
    if (chips[player] === 0) {
      playerElements(player).status.textContent = "çŠ¶æ€ï¼šå…¨ä¸‹";
    }
    playerElements(player).bet.textContent = `æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š${totalBets[player]}`;
    playerElements(player).chips.textContent = `ç­¹ç ï¼š${chips[player]}`;
    qs('#potLabel').textContent = `åº•æ± ï¼š${pot}`;
  }

  function newRound() {
    if (handActive) return;
    dealerIndex = (dealerIndex + 1) % NUM_PLAYERS;
    resetForNewHand();
    dealHoleCards();
    renderCommunity();
    renderPlayers();

    // å¼€å±€æ˜¾ç¤ºï¼šKai çš„ç‰Œï¼Œå…¶ä»–ç©å®¶éšè—
    postBlinds();
    renderPlayers();
    enableActionButtons(true);
    qs('#newRoundBtn').disabled = true;
    street = "preflop";
    qs('#streetLabel').textContent = `é˜¶æ®µï¼š${streetNames[street]}`;
    setStatusBar("æ–°å±€å¼€å§‹ï¼šPreflopï¼Œè½®åˆ° Kai é€‰æ‹©æ“ä½œã€‚");
  }

  function advanceStreet() {
    bets = new Array(NUM_PLAYERS).fill(0);
    currentBet = 0;

    if (street === "preflop") {
      street = "flop";
      while (communityCards.length < 3) {
        communityCards.push(deck.pop());
      }
    } else if (street === "flop") {
      street = "turn";
      if (communityCards.length < 4) {
        communityCards.push(deck.pop());
      }
    } else if (street === "turn") {
      street = "river";
      if (communityCards.length < 5) {
        communityCards.push(deck.pop());
      }
    }

    renderCommunity();
    renderPlayers();
    setStatusBar(`${streetNames[street]} é˜¶æ®µï¼Œè½®åˆ° Kai æ“ä½œã€‚`);
  }

  function revealRemainingBoard() {
    while (communityCards.length < 5 && deck.length > 0) {
      communityCards.push(deck.pop());
    }
    renderCommunity();
  }

  function awardPot(winners) {
    if (!winners || winners.length === 0 || pot <= 0) return;
    const share = Math.floor(pot / winners.length);
    winners.forEach(w => { chips[w] += share; });
    pot = 0;
    qs('#potLabel').textContent = `åº•æ± ï¼š${pot}`;
    renderPlayers();
  }

  function endHand() {
    handActive = false;
    enableActionButtons(false);
    qs('#newRoundBtn').disabled = false;
    street = "end";
    qs('#streetLabel').textContent = `é˜¶æ®µï¼š${streetNames[street]}`;
  }

  function doShowdown() {
    revealAll = true;
    renderCommunity();
    renderPlayers();

    const bestValues = [];
    const alive = [];
    for (let i = 0; i < NUM_PLAYERS; i++) {
      if (inHand[i] && playersCards[i].length === 2) {
        const val = evaluate7cards([...playersCards[i], ...communityCards]);
        bestValues.push(val);
        alive.push(i);
      }
    }

    if (alive.length === 0) {
      setStatusBar("æ— äººè·èƒœï¼Œåº•æ± ä½œåºŸã€‚");
      endHand();
      return;
    }

    let maxVal = bestValues[0];
    let winners = [alive[0]];
    for (let k = 1; k < alive.length; k++) {
      const cmp = compareHands(bestValues[k], maxVal);
      if (cmp > 0) {
        maxVal = bestValues[k];
        winners = [alive[k]];
      } else if (cmp === 0) {
        winners.push(alive[k]);
      }
    }

    awardPot(winners);

    for (let idx = 0; idx < alive.length; idx++) {
      const pIndex = alive[idx];
      const v = bestValues[idx];
      const elems = playerElements(pIndex);
      const category = v[0];
      let extra = "";
      if (winners.includes(pIndex)) {
        extra = winners.length === 1 ? "  â† èƒœè€…!" : "  â† å¹³å±€";
        elems.handType.classList.add('winner');
      }
      elems.handType.textContent = `ç‰Œå‹ï¼š${HAND_CATEGORY_NAME[category] || "æœªçŸ¥"}${extra}`;
    }

    if (winners.length === 1) {
      const w = winners[0];
      const who = (w === 0) ? "Kai" : `ç©å®¶ ${w + 1}`;
      setStatusBar(`æ‘Šç‰Œç»“æœï¼š${who} ä»¥ ${HAND_CATEGORY_NAME[maxVal[0]]} è·èƒœã€‚`);
    } else {
      const names = winners.map(w => (w === 0 ? "Kai" : `ç©å®¶ ${w + 1}`)).join("ï¼Œ");
      setStatusBar(`æ‘Šç‰Œç»“æœï¼š${names} ä»¥ ${HAND_CATEGORY_NAME[maxVal[0]]} å¹³åˆ†åº•æ± ã€‚`);
    }

    endHand();
  }

  // ---------- Kai çš„æ“ä½œï¼ˆå¯¹åº” action_*ï¼‰ ----------

  function actionCallOrCheck() {
    if (!handActive || !inHand[0]) return;
    const toCall = currentBet - bets[0];
    const statusElem = playerElements(0).status;
    if (toCall <= 0) {
      statusElem.textContent = "çŠ¶æ€ï¼šè¿‡ç‰Œ";
    } else {
      statusElem.textContent = "çŠ¶æ€ï¼šè·Ÿæ³¨";
      takeBet(0, toCall);
    }
    afterPlayerAction();
  }

  function actionRaise() {
    if (!handActive || !inHand[0]) return;
    const raiseAmount = 20;
    const targetBet = currentBet + raiseAmount;
    const alreadyPut = bets[0];
    let toPay = targetBet - alreadyPut;
    if (chips[0] <= 0) return;
    if (toPay <= 0) return;
    if (toPay > chips[0]) {
      toPay = chips[0];
    }

    playerElements(0).status.textContent = "çŠ¶æ€ï¼šåŠ æ³¨";
    takeBet(0, toPay);
    currentBet = alreadyPut + toPay;
    afterPlayerAction();
  }

  function actionFold() {
    if (!handActive || !inHand[0]) return;
    inHand[0] = false;
    playerElements(0).status.textContent = "çŠ¶æ€ï¼šå¼ƒç‰Œ";
    enableActionButtons(false);
    revealRemainingBoard();
    doShowdown();
  }

  // ---------- AIï¼ˆå¯¹åº” simple_ai_action + estimate_win_probability çš„ JS ç‰ˆæœ¬ï¼‰ ----------

  function estimateWinProbability(idx, numOpponents, numSimulations = 300) {
    const heroHole = playersCards[idx];
    const board = communityCards;

    const known = [...heroHole, ...board];

    const fullDeck = createDeck();
    const remaining = fullDeck.filter(c =>
      !known.some(k => k.rank === c.rank && k.suit === c.suit)
    );

    const neededCommunity = 5 - board.length;
    const cardsPerOpponent = 2;
    const neededTotal = neededCommunity + numOpponents * cardsPerOpponent;
    if (neededTotal <= 0 || neededTotal > remaining.length) return 0.0;

    let wins = 0;
    let ties = 0;

    for (let sim = 0; sim < numSimulations; sim++) {
      const sample = [];
      const tempDeck = [...remaining];
      for (let i = 0; i < neededTotal; i++) {
        const j = Math.floor(Math.random() * tempDeck.length);
        sample.push(tempDeck[j]);
        tempDeck.splice(j, 1);
      }

      let pos = 0;
      let futureBoard = [...board];
      if (neededCommunity > 0) {
        futureBoard = board.concat(sample.slice(pos, pos + neededCommunity));
        pos += neededCommunity;
      }

      const oppHands = [];
      for (let o = 0; o < numOpponents; o++) {
        oppHands.push(sample.slice(pos, pos + 2));
        pos += 2;
      }

      const heroBest = evaluate7cards(heroHole.concat(futureBoard));
      const oppBestList = oppHands.map(h => evaluate7cards(h.concat(futureBoard)));
      let bestOpp = oppBestList[0];
      for (let i = 1; i < oppBestList.length; i++) {
        if (compareHands(oppBestList[i], bestOpp) > 0) {
          bestOpp = oppBestList[i];
        }
      }

      const cmp = compareHands(heroBest, bestOpp);
      if (cmp > 0) wins += 1;
      else if (cmp === 0) ties += 1;
    }

    return (wins + 0.5 * ties) / numSimulations;
  }

  function aiAction(idx) {
    if (!inHand[idx] || chips[idx] <= 0) return;

    const toCall = currentBet - bets[idx];
    const opponents = inHand.filter((v, i) => v && i !== idx).length;

    const statusElem = playerElements(idx).status;

    if (opponents <= 0) {
      if (toCall > 0) {
        takeBet(idx, toCall);
        statusElem.textContent = "çŠ¶æ€ï¼šè·Ÿæ³¨ï¼ˆæ— å¯¹æ‰‹ï¼‰";
      } else {
        statusElem.textContent = "çŠ¶æ€ï¼šè¿‡ç‰Œ";
      }
      return;
    }

    const winProb = estimateWinProbability(idx, opponents, 80);

    if (toCall <= 0) {
      if (winProb > 0.7 && chips[idx] > 0) {
        const baseBet = Math.max(BIG_BLIND, Math.floor(pot * 0.5));
        const betAmount = Math.min(baseBet, chips[idx]);
        if (betAmount > 0) {
          currentBet = bets[idx] + betAmount;
          statusElem.textContent = `çŠ¶æ€ï¼šä¸»åŠ¨ä¸‹æ³¨ ${betAmount}ï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
          takeBet(idx, betAmount);
        } else {
          statusElem.textContent = `çŠ¶æ€ï¼šè¿‡ç‰Œï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
        }
      } else if (winProb > 0.45) {
        statusElem.textContent = `çŠ¶æ€ï¼šè¿‡ç‰Œï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
      } else {
        statusElem.textContent = `çŠ¶æ€ï¼šè¿‡ç‰Œï¼ˆå¼±ç‰Œï¼Œèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
      }
    } else {
      const potAfterCall = pot + toCall;
      const potOdds = potAfterCall > 0 ? (toCall / potAfterCall) : 1.0;

      if (winProb < potOdds * 0.8) {
        inHand[idx] = false;
        statusElem.textContent = `çŠ¶æ€ï¼šå¼ƒç‰Œï¼ˆèƒœç‡ ${winProb.toFixed(2)} < å½©æ± èµ”ç‡ ${potOdds.toFixed(2)}ï¼‰`;
        return;
      }

      takeBet(idx, toCall);

      const canRaise = chips[idx] > BIG_BLIND;
      if (winProb > potOdds * 1.5 && canRaise) {
        const extra = Math.min(
          Math.max(BIG_BLIND, Math.floor(pot * 0.3)),
          chips[idx]
        );
        if (extra > 0) {
          currentBet = bets[idx] + extra;
          takeBet(idx, extra);
          statusElem.textContent = `çŠ¶æ€ï¼šè·Ÿæ³¨å¹¶åŠ æ³¨ ${extra}ï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
        } else {
          statusElem.textContent = `çŠ¶æ€ï¼šè·Ÿæ³¨ï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
        }
      } else {
        statusElem.textContent = `çŠ¶æ€ï¼šè·Ÿæ³¨ï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼Œä¸é€‚åˆåŠ æ³¨ï¼‰`;
      }
    }
  }

  function afterPlayerAction() {
    for (let i = 1; i < NUM_PLAYERS; i++) {
      if (inHand[i] && chips[i] > 0) {
        aiAction(i);
      }
    }

    const alive = [];
    for (let i = 0; i < NUM_PLAYERS; i++) {
      if (inHand[i]) alive.push(i);
    }

    if (alive.length === 1) {
      const winner = alive[0];
      awardPot([winner]);
      const who = winner === 0 ? "Kai" : `ç©å®¶${winner + 1}`;
      setStatusBar(`æ‰€æœ‰äººå¼ƒç‰Œï¼Œ${who} ç›´æ¥èµ¢å¾—åº•æ± ã€‚`);
      endHand();
      return;
    }

    if (street === "river") {
      revealRemainingBoard();
      doShowdown();
    } else {
      advanceStreet();
    }
  }
  // === å°è›‡çœ¨çœ¼åŠ¨ç”» ===

// ä¿å­˜å°è›‡ç”»å¸ƒä¸Šä¸‹æ–‡
let snakeCtx = null;

// é‡ç»˜å°è›‡ï¼ˆwithBlink = true æ—¶é—­çœ¼ï¼‰
function drawSnake(withBlink = false) {
    const canvas = document.getElementById("snakeCanvas");
    if (!canvas) return;

    if (!snakeCtx) snakeCtx = canvas.getContext("2d");
    const ctx = snakeCtx;
    const img = new Image();
    img.src = "my_snake.png";
    img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    };
    

    
}
    // ğŸ å½©è›‹æŒ‰é’®é€»è¾‘
    const surpriseBtn = qs('#surpriseBtn');
  const surpriseModal = qs('#surpriseModal');
  const closeSurpriseBtn = qs('#closeSurpriseBtn');

  surpriseBtn.addEventListener('click', () => {
    surpriseModal.classList.remove('hidden');
  });

  closeSurpriseBtn.addEventListener('click', () => {
    surpriseModal.classList.add('hidden');
  });

  // ç‚¹å‡»é®ç½©ä¹Ÿå¯å…³é—­
  surpriseModal.addEventListener('click', (e) => {
    if (e.target === surpriseModal) {
      surpriseModal.classList.add('hidden');
    }
  });


  // ---------- äº‹ä»¶ç»‘å®š & åˆå§‹åŒ– ----------

  qs('#newRoundBtn').addEventListener('click', newRound);
  qs('#btnCall').addEventListener('click', actionCallOrCheck);
  qs('#btnRaise').addEventListener('click', actionRaise);
  qs('#btnFold').addEventListener('click', actionFold);

  function initEmptyUI() {
    communityCards = [];
    renderCommunity();
    renderPlayers();
    enableActionButtons(false);
  }

  document.addEventListener('DOMContentLoaded', initEmptyUI);
</script>
</body>
</html>
